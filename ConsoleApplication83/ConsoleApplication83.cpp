//----------------------------------------------------
// ИТА ЮФУ, ИКТИБ, МОП ЭВМ
// Программирование и основы теории алгоритмов
// Индивидуальное задание
// 11.01.2022
//----------------------------------------------------
#include "readfiles.h"
#include <iostream>
#define FILE_INPUT "input.txt"
#define FILE_REPORT "answer.txt"

int main() 
{
	setlocale(LC_ALL, "ru");

	//----------------------------------------------------
	// выделение памяти для входных данных и отчёта
	//----------------------------------------------------
	sReader::Result r;
	sReader::Report report;

	//----------------------------------------------------
	// Проверка на неполадки с файлом
	//----------------------------------------------------
	if (!sReader::Init(r))
	{
		return -1;
	}

	FILE* f;

	//----------------------------------------------------
	// Если не удалось открыть файл, возврат -1
	//----------------------------------------------------
	if (fopen_s(&f, FILE_INPUT, "r") != 0)
	{
		return -1;
	}

	//----------------------------------------------------
	// Переменные для чтения временного диапазона
	//----------------------------------------------------
	long long int by, bm, ey, em;

	//----------------------------------------------------
	// Считывание данных из input.txt
	//----------------------------------------------------
	fscanf_s(f, "%lld %s %lld.%lld-%lld.%lld", &r.query.flat, &r.query.taxes_name, 6, &bm, &by, &em, &ey);

	//----------------------------------------------------
	// Перевод даты в месяцы(начальный и конечный)
	//----------------------------------------------------
	r.query.month_start = (by - 2021) * 12 + (bm - 8);
	r.query.month_end = (ey - 2021) * 12 + (em - 8);

	//----------------------------------------------------
	// Выделение памяти для структуры
	//----------------------------------------------------
	sReader::Taxes taxe;
	bool success = false;

	//----------------------------------------------------
	// Поиск услуги по названию
	//----------------------------------------------------
	for (long long int i = 0; i < r.taxes_count; i++)
	{
		if (strcmp(r.taxes[i].name, r.query.taxes_name) == 0) 
		{
			taxe = r.taxes[i];
			success = true;
			break;
		}
	}

	//----------------------------------------------------
	// Условие, если услуга не нашлась
	//----------------------------------------------------
	if (!success)
	{
		return -1;
	}

	fclose(f);

	//----------------------------------------------------
	// Интервал количества месяцев
	//----------------------------------------------------
	report.mcount = r.query.month_end - r.query.month_start + 1;

	//----------------------------------------------------
	// Переменная для подсчёта количества показаний,
	// Массив показаний для ОДПУ
	//----------------------------------------------------
	long long int intvs = report.mcount + 1;
	long long int* p_ghmd = new long long int[intvs];

	//----------------------------------------------------
	// Чтение ОДПУ за нужные месяцы в порядке
	// возрастания дат
	//----------------------------------------------------
	for (long long int i = 0; i < r.ghmd_count; i++)
	{
		if (r.query.month_start - 1 <= r.ghmd[i].month && r.ghmd[i].month <= r.query.month_end) 
		{
			p_ghmd[r.ghmd[i].month - r.query.month_start + 1] = r.ghmd[i].list[taxe.number];
		}
	}

	//----------------------------------------------------
	// Проверка на начало диапазона с 9ого месяца
	//----------------------------------------------------
	if (r.query.month_start == 1)
	{
		p_ghmd[0] = p_ghmd[1];
	}

	//----------------------------------------------------
	// Массив для записей в отчёте
	// Массив для потреблений услуги по ОДПУ
	// Двумерный массив для номера квартиры и каждого месяца потребления услуг по ИПУ
	// Массив для показаний за каждый месяц
	//----------------------------------------------------
	report.list = new sReader::Record_Report[report.mcount];
	long long int* g_ghmd = new long long int[report.mcount];
	long long int** g_imd = new long long int*[r.flats_count];
	long long int* t_imd = new long long int[intvs];
	
	for (long long int i = 0; i < r.flats_count; i++) 
	{
		//----------------------------------------------------
		// Получение показаний ИПУ для i - ой квартиры
		//----------------------------------------------------
		for (long long int j = 0; j < r.imd_count; j++)
		{
			if (r.query.month_start - 1 <= r.imd[j].month && r.imd[j].month <= r.query.month_end && r.imd[j].flat == i + 1)
			{
				t_imd[r.imd[j].month - r.query.month_start + 1] = r.imd[j].list[taxe.number];
			}
		}

		//----------------------------------------------------
		// Проверка на начало диапазона с 9ого месяца
		//----------------------------------------------------
		if (r.query.month_start == 1)
		{
			t_imd[0] = t_imd[1];
		}

		g_imd[i] = new long long int[report.mcount];

		//----------------------------------------------------
		// Получение подребления для i - ой квартиры за каждый месяц
		//----------------------------------------------------
		for (long long int j = 0; j < report.mcount; j++) 
		{
			g_imd[i][j] = t_imd[j + 1] - t_imd[j];
		}
	}
	
	//----------------------------------------------------
	// Потребление ОДПУ за каждый месяц
	// Потребление заданной квартиры
	// Подсчёт потраченной суммы за месяц
	// Подсчёт общего потребления заданной квартиры
	//----------------------------------------------------
	for (long long int i = 0; i < report.mcount; i++) 
	{
		g_ghmd[i] = p_ghmd[i + 1] - p_ghmd[i];
		report.list[i].fsum = g_imd[r.query.flat - 1][i];
		report.list[i].fsum_cost = report.list[i].fsum * taxe.tariff;
		report.fsum += report.list[i].fsum;
	}
	
	for (long long int i = 0; i < report.mcount; i++) 
	{
		//----------------------------------------------------
		// Запись месяца для строчки отчёта
		//----------------------------------------------------
		report.list[i].month = r.query.month_start + i;

		//----------------------------------------------------
		// Подсчёт суммарного потребления по ИПУ
		//----------------------------------------------------
		long long int msum = 0;
		long long int sum = 0;
		for (long long int j = 0; j < r.flats_count; j++) 
		{
			msum += g_imd[j][i];
			sum += r.flats[j].count;
		}

		if (taxe.code == 0)
		{
			sum = r.gS;
		}


		float coefficient = taxe.code == 0 ? r.flats[r.query.flat - 1].S : r.flats[r.query.flat - 1].count;
		coefficient /= sum;

		//----------------------------------------------------
		// Подсчёт ОДН для заданной квартиры
		// Начисление ОДН для заданной квартиры
		// Подсчёт суммарного потребления ОДН
		//----------------------------------------------------
		report.list[i].odn = ((float)(g_ghmd[i] - msum) * coefficient);
		report.list[i].odn_cost = report.list[i].odn * taxe.tariff;
		report.odn += report.list[i].odn;
	}
	
	//----------------------------------------------------
	// Начисление суммарного потребления заданной услуги 
	// для заданной квартиры
	// Начисление суммарного потребления ОДН заданной услуги 
	// для заданной квартиры
	//----------------------------------------------------
	report.fsum_cost = report.fsum * taxe.tariff;
	report.odn_cost = report.odn * taxe.tariff;

	//----------------------------------------------------
	// Проверка на открытие файла report.txt
	//----------------------------------------------------
	if (fopen_s(&f, FILE_REPORT, "w") != 0)
	{
		return -1;
	}

	//----------------------------------------------------
	// Запись общей части отчёта
	//----------------------------------------------------
	fprintf_s(f, "%lld %lld %lld %lld\n%lld\n", report.fsum, report.fsum_cost, report.odn, report.odn_cost, report.mcount);

	//----------------------------------------------------
	// Запись отчёта за каждый месяц
	//----------------------------------------------------
	for (long long int i = 0; i < report.mcount; i++) 
	{
		report.list[i].month += 7;
		long long int y = report.list[i].month / 12;
		long long int m = (report.list[i].month % 12) + 1;
		fprintf_s(f, "%02d.%lld %lld %lld %lld %lld\n", m, 2021 + y, report.list[i].fsum, report.list[i].fsum_cost, report.list[i].odn, report.list[i].odn_cost);
	}

	fclose(f);

	//----------------------------------------------------
	// Очистка памяти
	//----------------------------------------------------
	delete[] p_ghmd;
	delete[] g_ghmd;

	for (long long int i = 0; i < r.flats_count; i++) 
	{
		delete[] g_imd[i];
	}

	delete[] g_imd;
	delete[] t_imd;

	return 0;
}
